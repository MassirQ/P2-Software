"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("@graphql-tools/merge");
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const pluralize_1 = __importDefault(require("pluralize"));
const validation_1 = require("./validation");
const resolvers_1 = require("./resolvers");
const aggregation_types_mapper_1 = require("./aggregations/aggregation-types-mapper");
const constants = __importStar(require("../constants"));
const Scalars = __importStar(require("./scalars"));
const point = __importStar(require("./point"));
const classes_1 = require("../classes");
const create_connection_fields_1 = __importDefault(require("./create-connection-fields"));
const create_relationship_fields_1 = __importDefault(require("./create-relationship-fields"));
const parse_exclude_directive_1 = __importDefault(require("./parse-exclude-directive"));
const parse_fulltext_directive_1 = __importDefault(require("./parse/parse-fulltext-directive"));
const parse_node_directive_1 = __importDefault(require("./parse-node-directive"));
const get_auth_1 = __importDefault(require("./get-auth"));
const get_custom_resolvers_1 = __importDefault(require("./get-custom-resolvers"));
const get_obj_field_meta_1 = __importDefault(require("./get-obj-field-meta"));
const get_sortable_fields_1 = __importDefault(require("./get-sortable-fields"));
const to_compose_1 = require("./to-compose");
const get_unique_fields_1 = __importDefault(require("./get-unique-fields"));
const get_where_fields_1 = __importDefault(require("./get-where-fields"));
const utils_1 = require("../utils/utils");
const upper_first_1 = require("../utils/upper-first");
const parse_query_options_directive_1 = require("./parse/parse-query-options-directive");
function makeAugmentedSchema(typeDefs, { enableRegex, skipValidateTypeDefs } = {}) {
    const document = (0, merge_1.mergeTypeDefs)(Array.isArray(typeDefs) ? typeDefs : [typeDefs]);
    if (!skipValidateTypeDefs) {
        (0, validation_1.validateDocument)(document);
    }
    const composer = new graphql_compose_1.SchemaComposer();
    // graphql-compose will break if the Point and CartesianPoint types are created but not used,
    // because it will purge the unused types but leave behind orphaned field resolvers
    //
    // These are flags to check whether the types are used and then create them if they are
    let pointInTypeDefs = false;
    let cartesianPointInTypeDefs = false;
    let relationships = [];
    composer.createObjectTC({
        name: "CreateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "DeleteInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    composer.createObjectTC({
        name: "UpdateInfo",
        fields: {
            bookmark: graphql_1.GraphQLString,
            nodesCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            nodesDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsCreated: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
            relationshipsDeleted: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt),
        },
    });
    const aggregationTypesMapper = new aggregation_types_mapper_1.AggregationTypesMapper(composer);
    composer.createInputTC({
        name: "QueryOptions",
        fields: {
            offset: "Int",
            limit: "Int",
        },
    });
    const sortDirection = composer.createEnumTC({
        name: "SortDirection",
        values: {
            ASC: {
                value: "ASC",
                description: "Sort by field values in ascending order.",
            },
            DESC: {
                value: "DESC",
                description: "Sort by field values in descending order.",
            },
        },
    });
    composer.createObjectTC({
        name: "PageInfo",
        description: "Pagination information (Relay)",
        fields: {
            hasNextPage: "Boolean!",
            hasPreviousPage: "Boolean!",
            startCursor: "String",
            endCursor: "String",
        },
    });
    const customResolvers = (0, get_custom_resolvers_1.default)(document);
    const scalars = document.definitions.filter((x) => x.kind === "ScalarTypeDefinition");
    const objectNodes = document.definitions.filter((x) => x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value));
    const enums = document.definitions.filter((x) => x.kind === "EnumTypeDefinition");
    const inputs = document.definitions.filter((x) => x.kind === "InputObjectTypeDefinition");
    let interfaces = document.definitions.filter((x) => x.kind === "InterfaceTypeDefinition");
    const directives = document.definitions.filter((x) => x.kind === "DirectiveDefinition");
    const unions = document.definitions.filter((x) => x.kind === "UnionTypeDefinition");
    const relationshipPropertyInterfaceNames = new Set();
    const interfaceRelationshipNames = new Set();
    const extraDefinitions = [
        ...enums,
        ...scalars,
        ...directives,
        ...inputs,
        ...unions,
        ...[
            customResolvers.customQuery,
            customResolvers.customMutation,
            customResolvers.customSubscription,
        ],
    ].filter(Boolean);
    Object.keys(Scalars).forEach((scalar) => composer.addTypeDefs(`scalar ${scalar}`));
    if (extraDefinitions.length) {
        composer.addTypeDefs((0, graphql_1.print)({ kind: graphql_1.Kind.DOCUMENT, definitions: extraDefinitions }));
    }
    const nodes = objectNodes.map((definition) => {
        var _a;
        const otherDirectives = (definition.directives || []).filter((x) => !["auth", "exclude", "node", "fulltext", "queryOptions"].includes(x.name.value));
        const authDirective = (definition.directives || []).find((x) => x.name.value === "auth");
        const excludeDirective = (definition.directives || []).find((x) => x.name.value === "exclude");
        const nodeDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "node");
        const fulltextDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "fulltext");
        const queryOptionsDirectiveDefinition = (definition.directives || []).find((x) => x.name.value === "queryOptions");
        const nodeInterfaces = [...(definition.interfaces || [])];
        const { interfaceAuthDirectives, interfaceExcludeDirectives } = nodeInterfaces.reduce((res, interfaceName) => {
            const iface = interfaces.find((i) => i.name.value === interfaceName.name.value);
            if (iface) {
                const interfaceAuthDirective = (iface.directives || []).find((x) => x.name.value === "auth");
                const interfaceExcludeDirective = (iface.directives || []).find((x) => x.name.value === "exclude");
                if (interfaceAuthDirective) {
                    res.interfaceAuthDirectives.push(interfaceAuthDirective);
                }
                if (interfaceExcludeDirective) {
                    res.interfaceExcludeDirectives.push(interfaceExcludeDirective);
                }
            }
            return res;
        }, { interfaceAuthDirectives: [], interfaceExcludeDirectives: [] });
        if (interfaceAuthDirectives.length > 1) {
            throw new Error(`Multiple interfaces of ${definition.name.value} have @auth directive - cannot determine directive to use`);
        }
        if (interfaceExcludeDirectives.length > 1) {
            throw new Error(`Multiple interfaces of ${definition.name.value} have @exclude directive - cannot determine directive to use`);
        }
        let auth;
        if (authDirective || interfaceAuthDirectives.length) {
            auth = (0, get_auth_1.default)(authDirective || interfaceAuthDirectives[0]);
        }
        let exclude;
        if (excludeDirective || interfaceExcludeDirectives.length) {
            exclude = (0, parse_exclude_directive_1.default)(excludeDirective || interfaceExcludeDirectives[0]);
        }
        let nodeDirective;
        if (nodeDirectiveDefinition) {
            nodeDirective = (0, parse_node_directive_1.default)(nodeDirectiveDefinition);
        }
        const nodeFields = (0, get_obj_field_meta_1.default)({
            obj: definition,
            enums,
            interfaces,
            scalars,
            unions,
            objects: objectNodes,
        });
        // Ensure that all required fields are returning either a scalar type or an enum
        const violativeRequiredField = nodeFields.computedFields
            .filter((f) => f.requiredFields.length)
            .map((f) => f.requiredFields)
            .flat()
            .find((requiredField) => ![
            ...nodeFields.primitiveFields,
            ...nodeFields.scalarFields,
            ...nodeFields.enumFields,
            ...nodeFields.temporalFields,
            ...nodeFields.cypherFields.filter((field) => field.isScalar || field.isEnum),
        ]
            .map((x) => x.fieldName)
            .includes(requiredField));
        if (violativeRequiredField) {
            throw new Error(`Cannot have ${violativeRequiredField} as a required field on node ${definition.name.value}. Required fields must return a scalar type.`);
        }
        let fulltextDirective;
        if (fulltextDirectiveDefinition) {
            fulltextDirective = (0, parse_fulltext_directive_1.default)({
                directive: fulltextDirectiveDefinition,
                nodeFields,
                definition,
            });
        }
        let queryOptionsDirective;
        if (queryOptionsDirectiveDefinition) {
            queryOptionsDirective = (0, parse_query_options_directive_1.parseQueryOptionsDirective)({
                directive: queryOptionsDirectiveDefinition,
                definition,
            });
        }
        nodeFields.relationFields.forEach((relationship) => {
            if (relationship.properties) {
                const propertiesInterface = interfaces.find((i) => i.name.value === relationship.properties);
                if (!propertiesInterface) {
                    throw new Error(`Cannot find interface specified in ${definition.name.value}.${relationship.fieldName}`);
                }
                relationshipPropertyInterfaceNames.add(relationship.properties);
            }
            if (relationship.interface) {
                interfaceRelationshipNames.add(relationship.typeMeta.name);
            }
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = nodeFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        const node = new classes_1.Node({
            name: definition.name.value,
            interfaces: nodeInterfaces,
            otherDirectives,
            ...nodeFields,
            // @ts-ignore we can be sure it's defined
            auth,
            // @ts-ignore we can be sure it's defined
            exclude,
            // @ts-ignore we can be sure it's defined
            nodeDirective,
            // @ts-ignore we can be sure it's defined
            fulltextDirective,
            queryOptionsDirective,
            description: (_a = definition.description) === null || _a === void 0 ? void 0 : _a.value,
        });
        return node;
    });
    const relationshipProperties = interfaces.filter((i) => relationshipPropertyInterfaceNames.has(i.name.value));
    const interfaceRelationships = interfaces.filter((i) => interfaceRelationshipNames.has(i.name.value));
    interfaces = interfaces.filter((i) => !(relationshipPropertyInterfaceNames.has(i.name.value) || interfaceRelationshipNames.has(i.name.value)));
    const relationshipFields = new Map();
    relationshipProperties.forEach((relationship) => {
        var _a;
        const authDirective = (relationship.directives || []).find((x) => x.name.value === "auth");
        if (authDirective) {
            throw new Error("Cannot have @auth directive on relationship properties interface");
        }
        (_a = relationship.fields) === null || _a === void 0 ? void 0 : _a.forEach((field) => {
            constants.RESERVED_INTERFACE_FIELDS.forEach(([fieldName, message]) => {
                if (field.name.value === fieldName) {
                    throw new Error(message);
                }
            });
            const forbiddenDirectives = ["auth", "relationship", "cypher"];
            forbiddenDirectives.forEach((directive) => {
                const found = (field.directives || []).find((x) => x.name.value === directive);
                if (found) {
                    throw new Error(`Cannot have @${directive} directive on relationship property`);
                }
            });
        });
        const relFields = (0, get_obj_field_meta_1.default)({
            enums,
            interfaces,
            objects: objectNodes,
            scalars,
            unions,
            obj: relationship,
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = relFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        relationshipFields.set(relationship.name.value, relFields);
        const baseFields = Object.values(relFields);
        const objectComposeFields = (0, to_compose_1.objectFieldsToComposeFields)(baseFields.reduce((acc, x) => [...acc, ...x], []));
        const propertiesInterface = composer.createInterfaceTC({
            name: relationship.name.value,
            fields: objectComposeFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Sort`,
            fields: propertiesInterface.getFieldNames().reduce((res, f) => {
                return { ...res, [f]: "SortDirection" };
            }, {}),
        });
        composer.createInputTC({
            name: `${relationship.name.value}UpdateInput`,
            fields: (0, to_compose_1.objectFieldsToUpdateInputFields)([
                ...relFields.primitiveFields.filter((field) => !field.autogenerate && !field.readonly),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ]),
        });
        const relationshipWhereFields = (0, get_where_fields_1.default)({
            typeName: relationship.name.value,
            fields: {
                scalarFields: relFields.scalarFields,
                enumFields: relFields.enumFields,
                temporalFields: relFields.temporalFields,
                pointFields: relFields.pointFields,
                primitiveFields: relFields.primitiveFields,
            },
            enableRegex,
        });
        composer.createInputTC({
            name: `${relationship.name.value}Where`,
            fields: relationshipWhereFields,
        });
        composer.createInputTC({
            name: `${relationship.name.value}CreateInput`,
            fields: (0, to_compose_1.objectFieldsToCreateInputFields)([
                ...relFields.primitiveFields.filter((field) => !field.autogenerate),
                ...relFields.scalarFields,
                ...relFields.enumFields,
                ...relFields.temporalFields.filter((field) => !field.timestamps),
                ...relFields.pointFields,
            ]),
        });
    });
    function ensureNonEmptyInput(nameOrInput) {
        const input = (0, utils_1.isString)(nameOrInput) ? composer.getITC(nameOrInput) : nameOrInput;
        if (input.getFieldNames().length === 0) {
            const faqURL = `https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/`;
            input.addFields({
                _emptyInput: {
                    type: "Boolean",
                    description: `Appears because this input type would be empty otherwise because this type is ` +
                        `composed of just generated and/or relationship properties. See ${faqURL}`,
                },
            });
        }
    }
    interfaceRelationships.forEach((interfaceRelationship) => {
        const implementations = objectNodes.filter((n) => { var _a; return (_a = n.interfaces) === null || _a === void 0 ? void 0 : _a.some((i) => i.name.value === interfaceRelationship.name.value); });
        const interfaceFields = (0, get_obj_field_meta_1.default)({
            enums,
            interfaces: [...interfaces, ...interfaceRelationships],
            objects: objectNodes,
            scalars,
            unions,
            obj: interfaceRelationship,
        });
        if (!pointInTypeDefs) {
            pointInTypeDefs = interfaceFields.pointFields.some((field) => field.typeMeta.name === "Point");
        }
        if (!cartesianPointInTypeDefs) {
            cartesianPointInTypeDefs = interfaceFields.pointFields.some((field) => field.typeMeta.name === "CartesianPoint");
        }
        const baseFields = Object.values(interfaceFields);
        const objectComposeFields = (0, to_compose_1.objectFieldsToComposeFields)(baseFields.reduce((acc, x) => [...acc, ...x], []));
        const composeInterface = composer.createInterfaceTC({
            name: interfaceRelationship.name.value,
            fields: objectComposeFields,
        });
        const interfaceOptionsInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}Options`, (tc) => {
            tc.addFields({
                limit: "Int",
                offset: "Int",
            });
        });
        const interfaceSortableFields = (0, get_sortable_fields_1.default)(interfaceFields).reduce((res, f) => ({
            ...res,
            [f.fieldName]: sortDirection.getTypeName(),
        }), {});
        if (Object.keys(interfaceSortableFields).length) {
            const interfaceSortInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}Sort`, (tc) => {
                tc.addFields(interfaceSortableFields);
                tc.setDescription(`Fields to sort ${(0, pluralize_1.default)(interfaceRelationship.name.value)} by. The order in which sorts are applied is not guaranteed when specifying many fields in one ${`${interfaceRelationship.name.value}Sort`} object.`);
            });
            interfaceOptionsInput.addFields({
                sort: {
                    description: `Specify one or more ${`${interfaceRelationship.name.value}Sort`} objects to sort ${(0, pluralize_1.default)(interfaceRelationship.name.value)} by. The sorts will be applied in the order in which they are arranged in the array.`,
                    type: interfaceSortInput.List,
                },
            });
        }
        const interfaceWhereFields = (0, get_where_fields_1.default)({
            typeName: interfaceRelationship.name.value,
            fields: {
                scalarFields: interfaceFields.scalarFields,
                enumFields: interfaceFields.enumFields,
                temporalFields: interfaceFields.temporalFields,
                pointFields: interfaceFields.pointFields,
                primitiveFields: interfaceFields.primitiveFields,
            },
            enableRegex,
            isInterface: true,
        });
        const [implementationsConnectInput, implementationsDeleteInput, implementationsDisconnectInput, implementationsUpdateInput, implementationsWhereInput,] = ["ConnectInput", "DeleteInput", "DisconnectInput", "UpdateInput", "Where"].map((suffix) => composer.createInputTC({
            name: `${interfaceRelationship.name.value}Implementations${suffix}`,
            fields: {},
        }));
        composer.createInputTC({
            name: `${interfaceRelationship.name.value}Where`,
            fields: { ...interfaceWhereFields, _on: implementationsWhereInput },
        });
        const interfaceCreateInput = composer.createInputTC(`${interfaceRelationship.name.value}CreateInput`);
        composer.getOrCreateITC(`${interfaceRelationship.name.value}UpdateInput`, (tc) => {
            tc.addFields({
                ...(0, to_compose_1.objectFieldsToUpdateInputFields)([
                    ...interfaceFields.primitiveFields,
                    ...interfaceFields.scalarFields,
                    ...interfaceFields.enumFields,
                    ...interfaceFields.temporalFields.filter((field) => !field.timestamps),
                    ...interfaceFields.pointFields,
                ]),
                _on: implementationsUpdateInput,
            });
        });
        (0, create_relationship_fields_1.default)({
            relationshipFields: interfaceFields.relationFields,
            schemaComposer: composer,
            composeNode: composeInterface,
            sourceName: interfaceRelationship.name.value,
            nodes,
            relationshipPropertyFields: relationshipFields,
        });
        relationships = [
            ...relationships,
            ...(0, create_connection_fields_1.default)({
                connectionFields: interfaceFields.connectionFields,
                schemaComposer: composer,
                composeNode: composeInterface,
                nodes,
                relationshipPropertyFields: relationshipFields,
            }),
        ];
        implementations.forEach((implementation) => {
            const node = nodes.find((n) => n.name === implementation.name.value);
            implementationsWhereInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}Where`,
                },
            });
            if (node.relationFields.length) {
                implementationsConnectInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}ConnectInput!]`,
                    },
                });
                implementationsDeleteInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}DeleteInput!]`,
                    },
                });
                implementationsDisconnectInput.addFields({
                    [implementation.name.value]: {
                        type: `[${implementation.name.value}DisconnectInput!]`,
                    },
                });
            }
            interfaceCreateInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}CreateInput`,
                },
            });
            implementationsUpdateInput.addFields({
                [implementation.name.value]: {
                    type: `${implementation.name.value}UpdateInput`,
                },
            });
        });
        if (implementationsConnectInput.getFieldNames().length) {
            const interfaceConnectInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}ConnectInput`, (tc) => {
                tc.addFields({ _on: implementationsConnectInput });
            });
            interfaceConnectInput.setField("_on", implementationsConnectInput);
        }
        if (implementationsDeleteInput.getFieldNames().length) {
            const interfaceDeleteInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}DeleteInput`, (tc) => {
                tc.addFields({ _on: implementationsDeleteInput });
            });
            interfaceDeleteInput.setField("_on", implementationsDeleteInput);
        }
        if (implementationsDisconnectInput.getFieldNames().length) {
            const interfaceDisconnectInput = composer.getOrCreateITC(`${interfaceRelationship.name.value}DisconnectInput`, (tc) => {
                tc.addFields({ _on: implementationsDisconnectInput });
            });
            interfaceDisconnectInput.setField("_on", implementationsDisconnectInput);
        }
        ensureNonEmptyInput(`${interfaceRelationship.name.value}CreateInput`);
        ensureNonEmptyInput(`${interfaceRelationship.name.value}UpdateInput`);
        [
            implementationsConnectInput,
            implementationsDeleteInput,
            implementationsDisconnectInput,
            implementationsUpdateInput,
            implementationsWhereInput,
        ].forEach((c) => ensureNonEmptyInput(c));
    });
    if (pointInTypeDefs) {
        // Every field (apart from CRS) in Point needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.point);
        composer.createInputTC(point.pointInput);
        composer.createInputTC(point.pointDistance);
    }
    if (cartesianPointInTypeDefs) {
        // Every field (apart from CRS) in CartesianPoint needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC(point.cartesianPoint);
        composer.createInputTC(point.cartesianPointInput);
        composer.createInputTC(point.cartesianPointDistance);
    }
    unions.forEach((union) => {
        if (union.types && union.types.length) {
            const fields = union.types.reduce((f, type) => {
                return { ...f, [type.name.value]: `${type.name.value}Where` };
            }, {});
            composer.createInputTC({
                name: `${union.name.value}Where`,
                fields,
            });
        }
    });
    nodes.forEach((node) => {
        var _a, _b, _c, _d;
        const nodeFields = (0, to_compose_1.objectFieldsToComposeFields)([
            ...node.primitiveFields,
            ...node.cypherFields,
            ...node.enumFields,
            ...node.scalarFields,
            ...node.interfaceFields,
            ...node.objectFields,
            ...node.unionFields,
            ...node.temporalFields,
            ...node.pointFields,
            ...node.computedFields,
        ]);
        const composeNode = composer.createObjectTC({
            name: node.name,
            fields: nodeFields,
            description: node.description,
            directives: (0, to_compose_1.graphqlDirectivesToCompose)(node.otherDirectives),
            interfaces: node.interfaces.map((x) => x.name.value),
        });
        const sortFields = (0, get_sortable_fields_1.default)(node).reduce((res, f) => ({
            ...res,
            [f.fieldName]: sortDirection.getTypeName(),
        }), {});
        if (Object.keys(sortFields).length) {
            const sortInput = composer.createInputTC({
                name: `${node.name}Sort`,
                fields: sortFields,
                description: `Fields to sort ${(0, upper_first_1.upperFirst)(node.plural)} by. The order in which sorts are applied is not guaranteed when specifying many fields in one ${`${node.name}Sort`} object.`,
            });
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: {
                    sort: {
                        description: `Specify one or more ${`${node.name}Sort`} objects to sort ${(0, upper_first_1.upperFirst)(node.plural)} by. The sorts will be applied in the order in which they are arranged in the array.`,
                        type: sortInput.NonNull.List,
                    },
                    limit: "Int",
                    offset: "Int",
                },
            });
        }
        else {
            composer.createInputTC({
                name: `${node.name}Options`,
                fields: { limit: "Int", offset: "Int" },
            });
        }
        const queryFields = (0, get_where_fields_1.default)({
            typeName: node.name,
            enableRegex,
            fields: {
                temporalFields: node.temporalFields,
                enumFields: node.enumFields,
                pointFields: node.pointFields,
                primitiveFields: node.primitiveFields,
                scalarFields: node.scalarFields,
            },
        });
        const countField = {
            type: "Int!",
            resolve: resolvers_1.numericalResolver,
            args: {},
        };
        composer.createObjectTC({
            name: `${node.name}AggregateSelection`,
            fields: {
                count: countField,
                ...[...node.primitiveFields, ...node.temporalFields].reduce((res, field) => {
                    if (field.typeMeta.array) {
                        return res;
                    }
                    const objectTypeComposer = aggregationTypesMapper.getAggregationType({
                        fieldName: field.typeMeta.name,
                        nullable: !field.typeMeta.required,
                    });
                    if (!objectTypeComposer)
                        return res;
                    res[field.fieldName] = objectTypeComposer.NonNull;
                    return res;
                }, {}),
            },
        });
        composer.createInputTC({
            name: `${node.name}Where`,
            fields: queryFields,
        });
        if (node.fulltextDirective) {
            const fields = node.fulltextDirective.indexes.reduce((res, index) => ({
                ...res,
                [index.name]: composer.createInputTC({
                    name: `${node.name}${(0, upper_first_1.upperFirst)(index.name)}Fulltext`,
                    fields: {
                        phrase: "String!",
                        score_EQUAL: "Int",
                    },
                }),
            }), {});
            composer.createInputTC({
                name: `${node.name}Fulltext`,
                fields,
            });
        }
        const uniqueFields = (0, get_unique_fields_1.default)(node);
        composer.createInputTC({
            name: `${node.name}UniqueWhere`,
            fields: uniqueFields,
        });
        composer.createInputTC({
            name: `${node.name}CreateInput`,
            fields: (0, to_compose_1.objectFieldsToCreateInputFields)([
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ].filter((f) => { var _a; return !((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate); })),
        });
        composer.createInputTC({
            name: `${node.name}UpdateInput`,
            fields: (0, to_compose_1.objectFieldsToUpdateInputFields)([
                ...node.primitiveFields,
                ...node.scalarFields,
                ...node.enumFields,
                ...node.temporalFields.filter((field) => !field.timestamps),
                ...node.pointFields,
            ]),
        });
        const mutationResponseTypeNames = node.mutationResponseTypeNames;
        composer.createObjectTC({
            name: mutationResponseTypeNames.create,
            fields: {
                info: `CreateInfo!`,
                [node.plural]: `[${node.name}!]!`,
            },
        });
        composer.createObjectTC({
            name: mutationResponseTypeNames.update,
            fields: {
                info: `UpdateInfo!`,
                [node.plural]: `[${node.name}!]!`,
            },
        });
        (0, create_relationship_fields_1.default)({
            relationshipFields: node.relationFields,
            schemaComposer: composer,
            composeNode,
            sourceName: node.name,
            nodes,
            relationshipPropertyFields: relationshipFields,
        });
        relationships = [
            ...relationships,
            ...(0, create_connection_fields_1.default)({
                connectionFields: node.connectionFields,
                schemaComposer: composer,
                composeNode,
                nodes,
                relationshipPropertyFields: relationshipFields,
            }),
        ];
        ensureNonEmptyInput(`${node.name}UpdateInput`);
        ensureNonEmptyInput(`${node.name}CreateInput`);
        const rootTypeFieldNames = node.rootTypeFieldNames;
        if (!((_a = node.exclude) === null || _a === void 0 ? void 0 : _a.operations.includes("read"))) {
            composer.Query.addFields({
                [rootTypeFieldNames.read]: (0, resolvers_1.findResolver)({ node }),
            });
            composer.Query.addFields({
                [rootTypeFieldNames.aggregate]: (0, resolvers_1.aggregateResolver)({ node }),
            });
        }
        if (!((_b = node.exclude) === null || _b === void 0 ? void 0 : _b.operations.includes("create"))) {
            composer.Mutation.addFields({
                [rootTypeFieldNames.create]: (0, resolvers_1.createResolver)({ node }),
            });
        }
        if (!((_c = node.exclude) === null || _c === void 0 ? void 0 : _c.operations.includes("delete"))) {
            composer.Mutation.addFields({
                [rootTypeFieldNames.delete]: (0, resolvers_1.deleteResolver)({ node }),
            });
        }
        if (!((_d = node.exclude) === null || _d === void 0 ? void 0 : _d.operations.includes("update"))) {
            composer.Mutation.addFields({
                [rootTypeFieldNames.update]: (0, resolvers_1.updateResolver)({
                    node,
                    schemaComposer: composer,
                }),
            });
        }
    });
    ["Mutation", "Query"].forEach((type) => {
        const objectComposer = composer[type];
        const cypherType = customResolvers[`customCypher${type}`];
        if (cypherType) {
            const objectFields = (0, get_obj_field_meta_1.default)({
                obj: cypherType,
                scalars,
                enums,
                interfaces,
                unions,
                objects: objectNodes,
            });
            const objectComposeFields = (0, to_compose_1.objectFieldsToComposeFields)([
                ...objectFields.enumFields,
                ...objectFields.interfaceFields,
                ...objectFields.primitiveFields,
                ...objectFields.relationFields,
                ...objectFields.scalarFields,
                ...objectFields.unionFields,
                ...objectFields.objectFields,
                ...objectFields.temporalFields,
            ]);
            objectComposer.addFields(objectComposeFields);
            objectFields.cypherFields.forEach((field) => {
                const customResolver = (0, resolvers_1.cypherResolver)({
                    field,
                    statement: field.statement,
                    type: type,
                });
                const composedField = (0, to_compose_1.objectFieldsToComposeFields)([field])[field.fieldName];
                objectComposer.addFields({ [field.fieldName]: { ...composedField, ...customResolver } });
            });
        }
    });
    interfaces.forEach((inter) => {
        var _a;
        const objectFields = (0, get_obj_field_meta_1.default)({ obj: inter, scalars, enums, interfaces, unions, objects: objectNodes });
        const baseFields = Object.values(objectFields);
        const objectComposeFields = (0, to_compose_1.objectFieldsToComposeFields)(baseFields.reduce((acc, x) => [...acc, ...x], []));
        composer.createInterfaceTC({
            name: inter.name.value,
            description: (_a = inter.description) === null || _a === void 0 ? void 0 : _a.value,
            fields: objectComposeFields,
            directives: (0, to_compose_1.graphqlDirectivesToCompose)((inter.directives || []).filter((x) => !["auth", "exclude"].includes(x.name.value))),
        });
    });
    if (!Object.values(composer.Mutation.getFields()).length) {
        composer.delete("Mutation");
    }
    const generatedTypeDefs = composer.toSDL();
    let parsedDoc = (0, graphql_1.parse)(generatedTypeDefs);
    function definionNodeHasName(x) {
        return "name" in x;
    }
    const emptyObjectsInterfaces = parsedDoc.definitions.filter((x) => (x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value)) ||
        x.kind === "InterfaceTypeDefinition").filter((x) => { var _a; return !((_a = x.fields) === null || _a === void 0 ? void 0 : _a.length); });
    if (emptyObjectsInterfaces.length) {
        throw new Error(`Objects and Interfaces must have one or more fields: ${emptyObjectsInterfaces
            .map((x) => x.name.value)
            .join(", ")}`);
    }
    const documentNames = parsedDoc.definitions.filter(definionNodeHasName).map((x) => x.name.value);
    const generatedResolvers = {
        ...Object.entries(composer.getResolveMethods()).reduce((res, [key, value]) => {
            if (!documentNames.includes(key)) {
                return res;
            }
            return { ...res, [key]: value };
        }, {}),
        ...Object.entries(Scalars).reduce((res, [name, scalar]) => {
            if (generatedTypeDefs.includes(`scalar ${name}\n`)) {
                res[name] = scalar;
            }
            return res;
        }, {}),
    };
    unions.forEach((union) => {
        if (!generatedResolvers[union.name.value]) {
            generatedResolvers[union.name.value] = { __resolveType: (root) => root.__resolveType };
        }
    });
    interfaceRelationships.forEach((i) => {
        if (!generatedResolvers[i.name.value]) {
            generatedResolvers[i.name.value] = { __resolveType: (root) => root.__resolveType };
        }
    });
    const seen = {};
    parsedDoc = {
        ...parsedDoc,
        definitions: parsedDoc.definitions.filter((definition) => {
            var _a;
            if (!("name" in definition)) {
                return true;
            }
            const n = (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (seen[n]) {
                return false;
            }
            seen[n] = n;
            return true;
        }),
    };
    return {
        nodes,
        relationships,
        typeDefs: parsedDoc,
        resolvers: generatedResolvers,
    };
}
exports.default = makeAugmentedSchema;
//# sourceMappingURL=make-augmented-schema.js.map