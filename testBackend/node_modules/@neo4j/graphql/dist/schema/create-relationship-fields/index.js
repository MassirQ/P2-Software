"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_compose_1 = require("graphql-compose");
const pluralize_1 = __importDefault(require("pluralize"));
const classes_1 = require("../../classes");
const constants_1 = require("../../constants");
const create_connect_or_create_field_1 = require("./create-connect-or-create-field");
const field_aggregation_composer_1 = require("../aggregations/field-aggregation-composer");
const upper_first_1 = require("../../utils/upper-first");
const directed_argument_1 = require("../directed-argument");
function createRelationshipFields({ relationshipFields, schemaComposer, 
// TODO: Ideally we come up with a solution where we don't have to pass the following into these kind of functions
composeNode, sourceName, nodes, relationshipPropertyFields, }) {
    const whereInput = schemaComposer.getITC(`${sourceName}Where`);
    const nodeCreateInput = schemaComposer.getITC(`${sourceName}CreateInput`);
    const nodeUpdateInput = schemaComposer.getITC(`${sourceName}UpdateInput`);
    let nodeConnectInput = undefined;
    let nodeDeleteInput = undefined;
    let nodeDisconnectInput = undefined;
    let nodeRelationInput = undefined;
    if (relationshipFields.length) {
        [nodeConnectInput, nodeDeleteInput, nodeDisconnectInput, nodeRelationInput] = [
            "ConnectInput",
            "DeleteInput",
            "DisconnectInput",
            "RelationInput",
        ].map((type) => schemaComposer.getOrCreateITC(`${sourceName}${type}`));
    }
    relationshipFields.forEach((rel) => {
        let hasNonGeneratedProperties = false;
        let hasNonNullNonGeneratedProperties = false;
        let anyNonNullRelProperties = false;
        let relFields;
        if (rel.properties) {
            relFields = relationshipPropertyFields.get(rel.properties);
            if (relFields) {
                const nonGeneratedProperties = [
                    ...relFields.primitiveFields.filter((field) => !field.autogenerate),
                    ...relFields.scalarFields,
                    ...relFields.enumFields,
                    ...relFields.temporalFields.filter((field) => !field.timestamps),
                    ...relFields.pointFields,
                ];
                hasNonGeneratedProperties = nonGeneratedProperties.length > 0;
                hasNonNullNonGeneratedProperties = nonGeneratedProperties.some((field) => field.typeMeta.required);
                anyNonNullRelProperties = [
                    ...relFields.primitiveFields,
                    ...relFields.scalarFields,
                    ...relFields.enumFields,
                    ...relFields.temporalFields,
                    ...relFields.pointFields,
                ].some((field) => field.typeMeta.required);
            }
        }
        if (rel.interface) {
            const refNodes = nodes.filter((x) => { var _a, _b; return (_b = (_a = rel.interface) === null || _a === void 0 ? void 0 : _a.implementations) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
            if (!rel.writeonly) {
                const baseNodeFieldArgs = {
                    options: `${rel.typeMeta.name}Options`,
                    where: `${rel.typeMeta.name}Where`,
                };
                const nodeFieldArgs = (0, directed_argument_1.addDirectedArgument)(baseNodeFieldArgs, rel);
                composeNode.addFields({
                    [rel.fieldName]: {
                        type: rel.typeMeta.pretty,
                        args: nodeFieldArgs,
                        description: rel.description,
                    },
                });
            }
            const connectWhere = schemaComposer.getOrCreateITC(`${rel.typeMeta.name}ConnectWhere`, (tc) => {
                tc.addFields({
                    node: `${rel.typeMeta.name}Where!`,
                });
            });
            const connectFieldInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectFieldInput`, (tc) => {
                tc.addFields({
                    ...(schemaComposer.has(`${rel.typeMeta.name}ConnectInput`)
                        ? { connect: `${rel.typeMeta.name}ConnectInput` }
                        : {}),
                    ...(rel.properties
                        ? { edge: `${rel.properties}CreateInput${anyNonNullRelProperties ? `!` : ""}` }
                        : {}),
                    where: connectWhere,
                });
            });
            const deleteFieldInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DeleteFieldInput`, (tc) => {
                tc.addFields({
                    ...(schemaComposer.has(`${rel.typeMeta.name}DeleteInput`)
                        ? { delete: `${rel.typeMeta.name}DeleteInput` }
                        : {}),
                    where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
                });
            });
            const disconnectFieldInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DisconnectFieldInput`, (tc) => {
                tc.addFields({
                    ...(schemaComposer.has(`${rel.typeMeta.name}DisconnectInput`)
                        ? { disconnect: `${rel.typeMeta.name}DisconnectInput` }
                        : {}),
                    where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
                });
            });
            const createFieldInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}CreateFieldInput`, (tc) => {
                tc.addFields({
                    node: `${rel.typeMeta.name}CreateInput!`,
                });
                if (rel.properties) {
                    tc.addFields({
                        edge: `${rel.properties}CreateInput!`,
                    });
                }
            });
            schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}UpdateConnectionInput`, (tc) => {
                tc.addFields({
                    ...(rel.properties ? { edge: `${rel.properties}UpdateInput` } : {}),
                    node: `${rel.typeMeta.name}UpdateInput`,
                });
            });
            const updateFieldInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}UpdateFieldInput`, (tc) => {
                tc.addFields({
                    connect: rel.typeMeta.array
                        ? `[${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectFieldInput!]`
                        : `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectFieldInput`,
                    create: rel.typeMeta.array
                        ? `[${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}CreateFieldInput!]`
                        : `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}CreateFieldInput`,
                    delete: rel.typeMeta.array
                        ? `[${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DeleteFieldInput!]`
                        : `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DeleteFieldInput`,
                    disconnect: rel.typeMeta.array
                        ? `[${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DisconnectFieldInput!]`
                        : `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}DisconnectFieldInput`,
                    update: `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}UpdateConnectionInput`,
                    where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
                });
            });
            const nodeFieldInput = schemaComposer.getOrCreateITC(`${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}FieldInput`, (tc) => {
                tc.addFields({
                    create: rel.typeMeta.array ? createFieldInput.NonNull.List : createFieldInput,
                    connect: rel.typeMeta.array ? connectFieldInput.NonNull.List : connectFieldInput,
                });
            });
            refNodes.forEach((n) => {
                const createName = `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}${n.name}CreateFieldInput`;
                if (!schemaComposer.has(createName)) {
                    schemaComposer.createInputTC({
                        name: createName,
                        fields: {
                            node: `${n.name}CreateInput!`,
                            ...(rel.properties ? { edge: `${rel.properties}CreateInput!` } : {}),
                        },
                    });
                }
            });
            if (!(composeNode instanceof graphql_compose_1.InterfaceTypeComposer)) {
                nodeCreateInput.addFields({
                    [rel.fieldName]: nodeFieldInput,
                });
            }
            nodeConnectInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? connectFieldInput.NonNull.List : connectFieldInput,
            });
            nodeDeleteInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? deleteFieldInput.NonNull.List : deleteFieldInput,
            });
            nodeDisconnectInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? disconnectFieldInput.NonNull.List : disconnectFieldInput,
            });
            nodeRelationInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? createFieldInput.NonNull.List : createFieldInput,
            });
            nodeUpdateInput.addFields({
                [rel.fieldName]: rel.typeMeta.array ? updateFieldInput.NonNull.List : updateFieldInput,
            });
            return;
        }
        if (rel.union) {
            const refNodes = nodes.filter((x) => { var _a, _b; return (_b = (_a = rel.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
            if (!rel.writeonly) {
                const baseNodeFieldArgs = {
                    options: "QueryOptions",
                    where: `${rel.typeMeta.name}Where`,
                };
                const nodeFieldArgs = (0, directed_argument_1.addDirectedArgument)(baseNodeFieldArgs, rel);
                composeNode.addFields({
                    [rel.fieldName]: {
                        type: rel.typeMeta.pretty,
                        args: nodeFieldArgs,
                        description: rel.description,
                    },
                });
            }
            const upperFieldName = (0, upper_first_1.upperFirst)(rel.fieldName);
            const upperNodeName = (0, upper_first_1.upperFirst)(sourceName);
            const typePrefix = `${upperNodeName}${upperFieldName}`;
            const [unionConnectInput, unionCreateInput, unionDeleteInput, unionDisconnectInput, unionUpdateInput] = [
                "Connect",
                "Create",
                "Delete",
                "Disconnect",
                "Update",
            ].map((operation) => schemaComposer.createInputTC({
                name: `${typePrefix}${operation}Input`,
                fields: {},
            }));
            const unionCreateFieldInput = schemaComposer.createInputTC({
                name: `${typePrefix}CreateFieldInput`,
                fields: {},
            });
            refNodes.forEach((n) => {
                const unionPrefix = `${sourceName}${upperFieldName}${n.name}`;
                const updateField = `${n.name}UpdateInput`;
                const nodeFieldInputName = `${unionPrefix}FieldInput`;
                const whereName = `${unionPrefix}ConnectionWhere`;
                const deleteName = `${unionPrefix}DeleteFieldInput`;
                const deleteField = rel.typeMeta.array ? `[${deleteName}!]` : `${deleteName}`;
                const disconnectName = `${unionPrefix}DisconnectFieldInput`;
                const disconnect = rel.typeMeta.array ? `[${disconnectName}!]` : `${disconnectName}`;
                const connectionUpdateInputName = `${unionPrefix}UpdateConnectionInput`;
                const createName = `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}${n.name}CreateFieldInput`;
                const create = rel.typeMeta.array ? `[${createName}!]` : createName;
                if (!schemaComposer.has(createName)) {
                    schemaComposer.createInputTC({
                        name: createName,
                        fields: {
                            node: `${n.name}CreateInput!`,
                            ...(hasNonGeneratedProperties
                                ? {
                                    edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}`,
                                }
                                : {}),
                        },
                    });
                    unionCreateInput.addFields({
                        [n.name]: nodeFieldInputName,
                    });
                    unionCreateFieldInput.addFields({
                        [n.name]: `[${createName}!]`,
                    });
                }
                const connectWhereName = `${n.name}ConnectWhere`;
                if (!schemaComposer.has(connectWhereName)) {
                    schemaComposer.createInputTC({
                        name: connectWhereName,
                        fields: {
                            node: `${n.name}Where!`,
                        },
                    });
                }
                const connectName = `${unionPrefix}ConnectFieldInput`;
                const connect = rel.typeMeta.array ? `[${connectName}!]` : `${connectName}`;
                if (!schemaComposer.has(connectName)) {
                    schemaComposer.createInputTC({
                        name: connectName,
                        fields: {
                            where: connectWhereName,
                            ...(n.relationFields.length
                                ? {
                                    connect: rel.typeMeta.array
                                        ? `[${n.name}ConnectInput!]`
                                        : `${n.name}ConnectInput`,
                                }
                                : {}),
                            ...(hasNonGeneratedProperties
                                ? {
                                    edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}`,
                                }
                                : {}),
                        },
                    });
                    unionConnectInput.addFields({
                        [n.name]: connect,
                    });
                }
                const updateFields = {
                    where: whereName,
                    update: connectionUpdateInputName,
                    connect,
                    disconnect: rel.typeMeta.array ? `[${disconnectName}!]` : disconnectName,
                    create,
                    delete: rel.typeMeta.array ? `[${deleteName}!]` : deleteName,
                };
                const connectOrCreate = (0, create_connect_or_create_field_1.createConnectOrCreateField)({
                    relationField: rel,
                    node: n,
                    schemaComposer,
                    hasNonGeneratedProperties,
                    hasNonNullNonGeneratedProperties,
                });
                if (connectOrCreate) {
                    updateFields.connectOrCreate = connectOrCreate;
                }
                const updateName = `${unionPrefix}UpdateFieldInput`;
                const update = rel.typeMeta.array ? `[${updateName}!]` : updateName;
                if (!schemaComposer.has(updateName)) {
                    schemaComposer.createInputTC({
                        name: updateName,
                        fields: updateFields,
                    });
                    unionUpdateInput.addFields({
                        [n.name]: update,
                    });
                }
                schemaComposer.createInputTC({
                    name: connectionUpdateInputName,
                    fields: {
                        ...(hasNonGeneratedProperties ? { edge: `${rel.properties}UpdateInput` } : {}),
                        node: updateField,
                    },
                });
                const fieldInputFields = {
                    create,
                    connect,
                };
                if (connectOrCreate) {
                    fieldInputFields.connectOrCreate = connectOrCreate;
                }
                schemaComposer.createInputTC({
                    name: nodeFieldInputName,
                    fields: fieldInputFields,
                });
                schemaComposer.createInputTC({
                    name: whereName,
                    fields: {
                        node: `${n.name}Where`,
                        node_NOT: `${n.name}Where`,
                        AND: `[${whereName}!]`,
                        OR: `[${whereName}!]`,
                        ...(rel.properties
                            ? {
                                edge: `${rel.properties}Where`,
                                edge_NOT: `${rel.properties}Where`,
                            }
                            : {}),
                    },
                });
                if (!schemaComposer.has(deleteName)) {
                    schemaComposer.createInputTC({
                        name: deleteName,
                        fields: {
                            where: whereName,
                            ...(n.relationFields.length
                                ? {
                                    delete: `${n.name}DeleteInput`,
                                }
                                : {}),
                        },
                    });
                    unionDeleteInput.addFields({
                        [n.name]: deleteField,
                    });
                }
                if (!schemaComposer.has(disconnectName)) {
                    schemaComposer.createInputTC({
                        name: disconnectName,
                        fields: {
                            where: whereName,
                            ...(n.relationFields.length
                                ? {
                                    disconnect: `${n.name}DisconnectInput`,
                                }
                                : {}),
                        },
                    });
                    unionDisconnectInput.addFields({
                        [n.name]: disconnect,
                    });
                }
                if (n.uniqueFields.length) {
                    // TODO: merge with createTopLevelConnectOrCreateInput
                    const nodeConnectOrCreateInput = schemaComposer.getOrCreateITC(`${sourceName}ConnectOrCreateInput`);
                    const nodeRelationConnectOrCreateInput = schemaComposer.getOrCreateITC(`${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectOrCreateInput`);
                    nodeConnectOrCreateInput.addFields({
                        [rel.fieldName]: nodeRelationConnectOrCreateInput,
                    });
                    const nodeFieldConnectOrCreateInputName = `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}${n.name}ConnectOrCreateFieldInput`;
                    nodeRelationConnectOrCreateInput.addFields({
                        [n.name]: rel.typeMeta.array
                            ? `[${nodeFieldConnectOrCreateInputName}!]`
                            : nodeFieldConnectOrCreateInputName,
                    });
                }
            });
            if (!(composeNode instanceof graphql_compose_1.InterfaceTypeComposer)) {
                nodeCreateInput.addFields({
                    [rel.fieldName]: unionCreateInput,
                });
            }
            nodeRelationInput.addFields({
                [rel.fieldName]: unionCreateFieldInput,
            });
            nodeUpdateInput.addFields({
                [rel.fieldName]: unionUpdateInput,
            });
            nodeConnectInput.addFields({
                [rel.fieldName]: unionConnectInput,
            });
            nodeDeleteInput.addFields({
                [rel.fieldName]: unionDeleteInput,
            });
            nodeDisconnectInput.addFields({
                [rel.fieldName]: unionDisconnectInput,
            });
            return;
        }
        const n = nodes.find((x) => x.name === rel.typeMeta.name);
        const updateField = `${n.name}UpdateInput`;
        const nodeFieldInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}FieldInput`;
        const nodeFieldUpdateInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}UpdateFieldInput`;
        const nodeFieldDeleteInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}DeleteFieldInput`;
        const nodeFieldDisconnectInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}DisconnectFieldInput`;
        const connectionUpdateInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}UpdateConnectionInput`;
        const relationshipWhereTypeInputName = `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}AggregateInput`;
        const [nodeWhereAggregationInput, edgeWhereAggregationInput] = [n, relFields].map((nodeOrRelFields) => {
            if (!nodeOrRelFields) {
                return;
            }
            const fields = constants_1.WHERE_AGGREGATION_TYPES.reduce((r, t) => {
                const f = [...nodeOrRelFields.primitiveFields, ...nodeOrRelFields.temporalFields].filter((y) => !y.typeMeta.array && y.typeMeta.name === t);
                if (!f.length) {
                    return r;
                }
                return r.concat(f);
            }, []);
            if (!fields.length) {
                return;
            }
            const name = `${sourceName}${(0, upper_first_1.upperFirst)(rel.fieldName)}${nodeOrRelFields instanceof classes_1.Node ? `Node` : `Edge`}AggregationWhereInput`;
            const aggregationInput = schemaComposer.createInputTC({
                name,
                fields: {
                    AND: `[${name}!]`,
                    OR: `[${name}!]`,
                },
            });
            fields.forEach((field) => {
                if (field.typeMeta.name === "ID") {
                    aggregationInput.addFields({
                        [`${field.fieldName}_EQUAL`]: "ID",
                    });
                    return;
                }
                if (field.typeMeta.name === "String") {
                    aggregationInput.addFields(constants_1.WHERE_AGGREGATION_OPERATORS.reduce((res, operator) => {
                        return {
                            ...res,
                            [`${field.fieldName}_${operator}`]: `${operator === "EQUAL" ? "String" : "Int"}`,
                            [`${field.fieldName}_AVERAGE_${operator}`]: "Float",
                            [`${field.fieldName}_LONGEST_${operator}`]: "Int",
                            [`${field.fieldName}_SHORTEST_${operator}`]: "Int",
                        };
                    }, {}));
                    return;
                }
                if (constants_1.WHERE_AGGREGATION_AVERAGE_TYPES.includes(field.typeMeta.name)) {
                    aggregationInput.addFields(constants_1.WHERE_AGGREGATION_OPERATORS.reduce((res, operator) => {
                        let averageType = "Float";
                        if (field.typeMeta.name === "BigInt") {
                            averageType = "BigInt";
                        }
                        if (field.typeMeta.name === "Duration") {
                            averageType = "Duration";
                        }
                        return {
                            ...res,
                            [`${field.fieldName}_${operator}`]: field.typeMeta.name,
                            [`${field.fieldName}_AVERAGE_${operator}`]: averageType,
                            [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name,
                            [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name,
                            ...(field.typeMeta.name !== "Duration"
                                ? { [`${field.fieldName}_SUM_${operator}`]: field.typeMeta.name }
                                : {}),
                        };
                    }, {}));
                    return;
                }
                aggregationInput.addFields(constants_1.WHERE_AGGREGATION_OPERATORS.reduce((res, operator) => ({
                    ...res,
                    [`${field.fieldName}_${operator}`]: field.typeMeta.name,
                    [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name,
                    [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name,
                }), {}));
            });
            // eslint-disable-next-line consistent-return
            return aggregationInput;
        });
        const whereAggregateInput = schemaComposer.createInputTC({
            name: relationshipWhereTypeInputName,
            fields: {
                count: "Int",
                count_LT: "Int",
                count_LTE: "Int",
                count_GT: "Int",
                count_GTE: "Int",
                AND: `[${relationshipWhereTypeInputName}!]`,
                OR: `[${relationshipWhereTypeInputName}!]`,
                ...(nodeWhereAggregationInput ? { node: nodeWhereAggregationInput } : {}),
                ...(edgeWhereAggregationInput ? { edge: edgeWhereAggregationInput } : {}),
            },
        });
        whereInput.addFields({
            ...{
                [rel.fieldName]: `${n.name}Where`,
                [`${rel.fieldName}_NOT`]: `${n.name}Where`,
                [`${rel.fieldName}Aggregate`]: whereAggregateInput,
            },
        });
        // n..m Relationships
        if (rel.typeMeta.array) {
            // Add filters for each list predicate
            whereInput.addFields(["ALL", "NONE", "SINGLE", "SOME"].reduce((acc, filter) => ({
                ...acc,
                [`${rel.fieldName}_${filter}`]: {
                    type: `${n.name}Where`,
                    // e.g. "Return Movies where all of the related Actors match this filter"
                    description: `Return ${(0, pluralize_1.default)(sourceName)} where ${filter !== "SINGLE" ? filter.toLowerCase() : "one"} of the related ${(0, pluralize_1.default)(rel.typeMeta.name)} match this filter`,
                },
            }), {}));
            // Deprecate existing filters
            whereInput.setFieldDirectiveByName(rel.fieldName, "deprecated", {
                reason: `Use \`${rel.fieldName}_SOME\` instead.`,
            });
            whereInput.setFieldDirectiveByName(`${rel.fieldName}_NOT`, "deprecated", {
                reason: `Use \`${rel.fieldName}_NONE\` instead.`,
            });
        }
        const createName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}CreateFieldInput`;
        const create = rel.typeMeta.array ? `[${createName}!]` : createName;
        schemaComposer.getOrCreateITC(createName, (tc) => {
            tc.addFields({
                node: `${n.name}CreateInput!`,
                ...(hasNonGeneratedProperties
                    ? { edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}` }
                    : {}),
            });
        });
        const connectWhereName = `${n.name}ConnectWhere`;
        schemaComposer.getOrCreateITC(connectWhereName, (tc) => {
            tc.addFields({
                node: `${n.name}Where!`,
            });
        });
        const connectName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectFieldInput`;
        const connect = rel.typeMeta.array ? `[${connectName}!]` : connectName;
        schemaComposer.getOrCreateITC(connectName, (tc) => {
            tc.addFields({
                where: connectWhereName,
                ...(n.relationFields.length
                    ? { connect: rel.typeMeta.array ? `[${n.name}ConnectInput!]` : `${n.name}ConnectInput` }
                    : {}),
                ...(hasNonGeneratedProperties
                    ? { edge: `${rel.properties}CreateInput${hasNonNullNonGeneratedProperties ? `!` : ""}` }
                    : {}),
            });
        });
        if (!rel.writeonly) {
            const nodeFieldsBaseArgs = {
                where: `${rel.typeMeta.name}Where`,
                options: `${rel.typeMeta.name}Options`,
            };
            const nodeFieldsArgs = (0, directed_argument_1.addDirectedArgument)(nodeFieldsBaseArgs, rel);
            composeNode.addFields({
                [rel.fieldName]: {
                    type: rel.typeMeta.pretty,
                    args: nodeFieldsArgs,
                    description: rel.description,
                },
            });
            if (composeNode instanceof graphql_compose_1.ObjectTypeComposer) {
                const baseTypeName = `${sourceName}${n.name}${(0, upper_first_1.upperFirst)(rel.fieldName)}`;
                const fieldAggregationComposer = new field_aggregation_composer_1.FieldAggregationComposer(schemaComposer);
                const aggregationTypeObject = fieldAggregationComposer.createAggregationTypeObject(baseTypeName, n, relFields);
                const aggregationFieldsBaseArgs = {
                    where: `${rel.typeMeta.name}Where`,
                };
                const aggregationFieldsArgs = (0, directed_argument_1.addDirectedArgument)(aggregationFieldsBaseArgs, rel);
                composeNode.addFields({
                    [`${rel.fieldName}Aggregate`]: {
                        type: aggregationTypeObject,
                        args: aggregationFieldsArgs,
                    },
                });
            }
        }
        schemaComposer.getOrCreateITC(connectionUpdateInputName, (tc) => {
            tc.addFields({
                node: updateField,
                ...(hasNonGeneratedProperties ? { edge: `${rel.properties}UpdateInput` } : {}),
            });
        });
        const connectOrCreate = (0, create_connect_or_create_field_1.createConnectOrCreateField)({
            relationField: rel,
            node: n,
            schemaComposer,
            hasNonGeneratedProperties,
            hasNonNullNonGeneratedProperties,
        });
        const updateFields = {
            where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
            update: connectionUpdateInputName,
            connect,
            disconnect: rel.typeMeta.array ? `[${nodeFieldDisconnectInputName}!]` : nodeFieldDisconnectInputName,
            create,
            delete: rel.typeMeta.array ? `[${nodeFieldDeleteInputName}!]` : nodeFieldDeleteInputName,
        };
        if (connectOrCreate) {
            updateFields.connectOrCreate = connectOrCreate;
        }
        schemaComposer.getOrCreateITC(nodeFieldUpdateInputName, (tc) => {
            tc.addFields(updateFields);
        });
        const mutationFields = {
            create,
            connect,
        };
        if (connectOrCreate) {
            mutationFields.connectOrCreate = connectOrCreate;
        }
        schemaComposer.getOrCreateITC(nodeFieldInputName, (tc) => {
            tc.addFields(mutationFields);
        });
        if (!schemaComposer.has(nodeFieldDeleteInputName)) {
            schemaComposer.createInputTC({
                name: nodeFieldDeleteInputName,
                fields: {
                    where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
                    ...(n.relationFields.length ? { delete: `${n.name}DeleteInput` } : {}),
                },
            });
        }
        if (!schemaComposer.has(nodeFieldDisconnectInputName)) {
            schemaComposer.createInputTC({
                name: nodeFieldDisconnectInputName,
                fields: {
                    where: `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectionWhere`,
                    ...(n.relationFields.length ? { disconnect: `${n.name}DisconnectInput` } : {}),
                },
            });
        }
        nodeRelationInput.addFields({
            [rel.fieldName]: create,
        });
        if (!(composeNode instanceof graphql_compose_1.InterfaceTypeComposer)) {
            nodeCreateInput.addFields({
                [rel.fieldName]: nodeFieldInputName,
            });
        }
        nodeUpdateInput.addFields({
            [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldUpdateInputName}!]` : nodeFieldUpdateInputName,
        });
        nodeDeleteInput.addFields({
            [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldDeleteInputName}!]` : nodeFieldDeleteInputName,
        });
        nodeConnectInput.addFields({
            [rel.fieldName]: connect,
        });
        nodeDisconnectInput.addFields({
            [rel.fieldName]: rel.typeMeta.array ? `[${nodeFieldDisconnectInputName}!]` : nodeFieldDisconnectInputName,
        });
        if (n.uniqueFields.length) {
            createTopLevelConnectOrCreateInput({ schemaComposer, sourceName, rel });
        }
    });
}
function createTopLevelConnectOrCreateInput({ schemaComposer, sourceName, rel, }) {
    const nodeConnectOrCreateInput = schemaComposer.getOrCreateITC(`${sourceName}ConnectOrCreateInput`);
    const nodeFieldConnectOrCreateInputName = `${rel.connectionPrefix}${(0, upper_first_1.upperFirst)(rel.fieldName)}ConnectOrCreateFieldInput`;
    nodeConnectOrCreateInput.addFields({
        [rel.fieldName]: rel.typeMeta.array
            ? `[${nodeFieldConnectOrCreateInputName}!]`
            : nodeFieldConnectOrCreateInputName,
    });
}
exports.default = createRelationshipFields;
//# sourceMappingURL=index.js.map