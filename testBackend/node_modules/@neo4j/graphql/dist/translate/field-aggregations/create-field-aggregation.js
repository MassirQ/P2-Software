"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFieldAggregation = void 0;
const utils_1 = require("./utils");
const AggregationSubQueries = __importStar(require("./aggregation-sub-queries"));
const field_aggregations_auth_1 = require("./field-aggregations-auth");
const aggregation_sub_queries_1 = require("./aggregation-sub-queries");
const map_to_db_property_1 = __importDefault(require("../../utils/map-to-db-property"));
const create_where_and_params_1 = __importDefault(require("../where/create-where-and-params"));
const stringify_object_1 = require("../utils/stringify-object");
const apoc_run_1 = require("../utils/apoc-run");
const field_aggregation_composer_1 = require("../../schema/aggregations/field-aggregation-composer");
const upper_first_1 = require("../../utils/upper-first");
const get_relationship_direction_1 = require("../cypher-builder/get-relationship-direction");
const subqueryNodeAlias = "n";
const subqueryRelationAlias = "r";
function createFieldAggregation({ context, nodeLabel, node, field, }) {
    const relationAggregationField = node.relationFields.find((x) => {
        return `${x.fieldName}Aggregate` === field.name;
    });
    const connectionField = node.connectionFields.find((x) => {
        return `${relationAggregationField === null || relationAggregationField === void 0 ? void 0 : relationAggregationField.fieldName}Connection` === x.fieldName;
    });
    if (!relationAggregationField || !connectionField)
        return undefined;
    const referenceNode = (0, utils_1.getReferenceNode)(context, relationAggregationField);
    const referenceRelation = (0, utils_1.getReferenceRelation)(context, connectionField);
    if (!referenceNode || !referenceRelation)
        return undefined;
    const fieldPathBase = `${node.name}${referenceNode.name}${(0, upper_first_1.upperFirst)(relationAggregationField.fieldName)}`;
    const aggregationFields = getAggregationFields(fieldPathBase, field);
    const authData = (0, field_aggregations_auth_1.createFieldAggregationAuth)({
        node: referenceNode,
        context,
        subqueryNodeAlias,
        nodeFields: aggregationFields.node,
    });
    const [whereQuery, whereParams] = (0, create_where_and_params_1.default)({
        whereInput: field.args.where || {},
        varName: subqueryNodeAlias,
        node: referenceNode,
        context,
        recursing: true,
        chainStr: `${nodeLabel}_${field.name}_${subqueryNodeAlias}`,
    });
    const targetPattern = createTargetPattern({
        nodeLabel,
        relationField: relationAggregationField,
        referenceNode,
        context,
        directed: field.args.directed,
    });
    const matchWherePattern = (0, aggregation_sub_queries_1.createMatchWherePattern)(targetPattern, authData, whereQuery);
    const apocRunParams = {
        ...(0, apoc_run_1.serializeParamsForApocRun)(whereParams),
        ...(0, utils_1.serializeAuthParamsForApocRun)(authData),
    };
    return {
        query: (0, stringify_object_1.stringifyObject)({
            count: aggregationFields.count
                ? createCountQuery({
                    nodeLabel,
                    matchWherePattern,
                    targetAlias: subqueryNodeAlias,
                    params: apocRunParams,
                })
                : undefined,
            node: aggregationFields.node
                ? createAggregationQuery({
                    nodeLabel,
                    matchWherePattern,
                    fields: aggregationFields.node,
                    fieldAlias: subqueryNodeAlias,
                    graphElement: referenceNode,
                    params: apocRunParams,
                })
                : undefined,
            edge: aggregationFields.edge
                ? createAggregationQuery({
                    nodeLabel,
                    matchWherePattern,
                    fields: aggregationFields.edge,
                    fieldAlias: subqueryRelationAlias,
                    graphElement: referenceRelation,
                    params: apocRunParams,
                })
                : undefined,
        }),
        params: { ...authData.params, ...whereParams },
    };
}
exports.createFieldAggregation = createFieldAggregation;
function getAggregationFields(fieldPathBase, field) {
    var _a, _b;
    const aggregationFields = field.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.field}`];
    const node = (_a = (0, utils_1.getFieldByName)("node", aggregationFields)) === null || _a === void 0 ? void 0 : _a.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.node}`];
    const edge = (_b = (0, utils_1.getFieldByName)("edge", aggregationFields)) === null || _b === void 0 ? void 0 : _b.fieldsByTypeName[`${fieldPathBase}${field_aggregation_composer_1.FieldAggregationSchemaTypes.edge}`];
    const count = (0, utils_1.getFieldByName)("count", aggregationFields);
    return { count, edge, node };
}
function createTargetPattern({ nodeLabel, relationField, referenceNode, context, directed, }) {
    const { inStr, outStr } = (0, get_relationship_direction_1.getRelationshipDirection)(relationField, { directed });
    const nodeOutStr = `(${subqueryNodeAlias}${referenceNode.getLabelString(context)})`;
    return `(${nodeLabel})${inStr}[${subqueryRelationAlias}:${relationField.type}]${outStr}${nodeOutStr}`;
}
function createCountQuery({ nodeLabel, matchWherePattern, targetAlias, params, }) {
    const apocCount = (0, apoc_run_1.wrapInApocRunFirstColumn)(AggregationSubQueries.countQuery(matchWherePattern, targetAlias), {
        ...params,
        [nodeLabel]: nodeLabel,
    });
    return `head(${apocCount})`;
}
function createAggregationQuery({ nodeLabel, matchWherePattern, fields, fieldAlias, graphElement, params, }) {
    const fieldsSubQueries = Object.values(fields).reduce((acc, field) => {
        const fieldType = (0, utils_1.getFieldType)(field);
        const dbProperty = (0, map_to_db_property_1.default)(graphElement, field.name);
        const aggregationQuery = (0, apoc_run_1.wrapInApocRunFirstColumn)(getAggregationSubquery({
            matchWherePattern,
            fieldName: dbProperty || field.name,
            type: fieldType,
            targetAlias: fieldAlias,
        }), {
            ...params,
            [nodeLabel]: nodeLabel,
        });
        acc[field.alias] = `head(${aggregationQuery})`;
        return acc;
    }, {});
    return (0, stringify_object_1.stringifyObject)(fieldsSubQueries);
}
function getAggregationSubquery({ matchWherePattern, fieldName, type, targetAlias, }) {
    switch (type) {
        case utils_1.AggregationType.String:
        case utils_1.AggregationType.Id:
            return AggregationSubQueries.stringAggregationQuery(matchWherePattern, fieldName, targetAlias);
        case utils_1.AggregationType.Int:
        case utils_1.AggregationType.BigInt:
        case utils_1.AggregationType.Float:
            return AggregationSubQueries.numberAggregationQuery(matchWherePattern, fieldName, targetAlias);
        case utils_1.AggregationType.DateTime:
            return AggregationSubQueries.dateTimeAggregationQuery(matchWherePattern, fieldName, targetAlias);
        default:
            return AggregationSubQueries.defaultAggregationQuery(matchWherePattern, fieldName, targetAlias);
    }
}
//# sourceMappingURL=create-field-aggregation.js.map