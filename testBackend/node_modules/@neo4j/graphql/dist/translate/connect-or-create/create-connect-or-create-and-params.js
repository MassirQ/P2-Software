"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectOrCreateAndParams = void 0;
const build_merge_statement_1 = require("../cypher-builder/build-merge-statement");
const create_auth_and_params_1 = __importDefault(require("../create-auth-and-params"));
const constants_1 = require("../../constants");
const utils_1 = require("../../utils/utils");
const wrap_in_call_1 = require("../utils/wrap-in-call");
const join_statements_1 = require("../cypher-builder/join-statements");
function createConnectOrCreateAndParams({ input, varName, parentVar, relationField, refNode, context, }) {
    const statements = (0, utils_1.asArray)(input).map((inputItem, index) => {
        const subqueryBaseName = `${varName}${index}`;
        return createConnectOrCreatePartialStatement({
            input: inputItem,
            baseName: subqueryBaseName,
            parentVar,
            relationField,
            refNode,
            context,
        });
    });
    const [statement, params] = (0, join_statements_1.joinStatements)(statements);
    return [(0, wrap_in_call_1.wrapInCall)(statement, parentVar), params];
}
exports.createConnectOrCreateAndParams = createConnectOrCreateAndParams;
function createConnectOrCreatePartialStatement({ input, baseName, parentVar, relationField, refNode, context, }) {
    const mergeRelatedNodeStatement = mergeRelatedNode({
        input,
        baseName,
        refNode,
        context,
    });
    const mergeRelationStatement = mergeRelation({
        input,
        baseName,
        context,
        parentVar,
        relationField,
    });
    const authStatement = createAuthStatement({
        node: refNode,
        context,
        nodeName: baseName,
    });
    return (0, join_statements_1.joinStatements)([authStatement, mergeRelatedNodeStatement, mergeRelationStatement]);
}
function mergeRelatedNode({ input, baseName, refNode, context, }) {
    var _a, _b;
    const whereNodeParameters = (_a = input.where) === null || _a === void 0 ? void 0 : _a.node;
    const onCreateNode = (_b = input.onCreate) === null || _b === void 0 ? void 0 : _b.node;
    return (0, build_merge_statement_1.buildMergeStatement)({
        sourceNode: {
            node: refNode,
            varName: baseName,
            parameters: whereNodeParameters,
            onCreate: onCreateNode,
        },
        context,
    });
}
function mergeRelation({ input, baseName, parentVar, context, relationField, }) {
    var _a;
    const onCreateEdge = (_a = input.onCreate) === null || _a === void 0 ? void 0 : _a.edge;
    return (0, build_merge_statement_1.buildMergeStatement)({
        sourceNode: {
            varName: parentVar,
        },
        targetNode: {
            varName: baseName,
        },
        relationship: {
            relationField,
            onCreate: onCreateEdge,
        },
        context,
    });
}
function createAuthStatement({ node, context, nodeName, i, }) {
    if (!node.auth)
        return undefined;
    const indexStr = i === undefined ? "" : String(i);
    const auth = (0, create_auth_and_params_1.default)({
        entity: node,
        operations: ["CONNECT", "CREATE"],
        context,
        allow: { parentNode: node, varName: nodeName, chainStr: `${nodeName}${node.name}${indexStr}_allow` },
    });
    if (!auth[0])
        return undefined;
    return (0, join_statements_1.joinStatements)(["CALL apoc.util.validate(NOT(", auth, `), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`], "");
}
//# sourceMappingURL=create-connect-or-create-and-params.js.map